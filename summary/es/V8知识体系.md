# V8知识图谱

![V8知识图谱](https://i.loli.net/2020/10/17/GCgWVNR2r7mZBz8.jpg)



# V8执行代码

V8是一台虚拟计算机，简称虚拟机。

计算机为什么要对JS这些高级语言进行编译？

1.因为人类要想跟CPU进行沟通，对CPU下命令，就需要把我们想说的话用二进制的方式表达出来。

2.工程师们给CPU提供一堆指令，这一堆指令就叫做指令集，给这一堆指令集起一个术语叫做：机器语言。

3.为什么需要给CPU提供一堆指令呢，因为为了让CPU能够完成复杂的任务。

4.矛盾点出来了：人类很难读懂和记忆二进制的指令代码，但是CPU却能看得懂。所以我们根据这堆二进制指令创造了方便人类记忆的符号，我们叫它汇编指令集。

5.也就是说汇编指令集的产生原因是人类为了方便读懂要给CPU下达什么指令而产生的。就好像我们无法记忆ip地址，于是有了方便记忆的域名。

6.汇编语言是产生了，但是人类现在是方便阅读要给CPU下达什么命令了，但是下达后的语言是汇编语言，CPU又读不懂了，这样子怎么办呢？

7.于是在这样子的一个环境下，汇编编译器就产生了，它把人类给CPU下达的汇编指令翻译成了CPU直接能读懂和执行的代码-二进制代码。

8.汇编语言出现的意义就是让程序员更好的给CPU下达命令，同时也方便记忆和交流。

9.因为不同的CPU拥有着不同的指令集，也就是说我们要让CPU做一个加法运算，不同的CPU对应着的这个加法操作的二进制代码是不一样的，如此一来上层的汇编语言实现的代码也就不一样了，那么都是一个加法，但是实现的方式都完全不同，这样子很难做到统一。在这种情况下，我们在编写汇编语言的时候，还要额外掌握处理器架构相关的硬件知识，很麻烦。也许我们只关心加法这个操作要这么做。

10.在以上这种问题环境下，人们在汇编语言之上设计出了能够适应多种CPU架构的语言，这种语言能够使你专心地去处理业务逻辑，它就是JS这些高级语言。

11.好了，高级语言出来了，解决了上述的问题，但是同样的高级语言CPU也看不懂。别忘了CPU永远只能看懂二进制代码。于是为了达到这样一个目的，让CPU来执行这些代码，人们想出了两种方式：

a.解释执行方式

b.编译执行方式

a,b两种方式，前面步骤都是一样的，如下：

11-1: 使用解析器，接收一段要被执行的JS代码，然后输出中间代码

接下来对于解释执行和编译执行就会产生分歧了：

对于a.解释执行来说，会使用解释器接收中间代码，然后在内部执行后输出的就是结果

对于b.编译执行来说，会使用编译器接收中间代码，然后输出机器代码，也就是01二进制的代码，把这些二进制代码用文件的形式保存在磁盘。或者直接让虚拟机把这些二进制代码保存到内存里，什么时候想要执行了就直接执行这些二进制代码就OK。

12.对于不同公司的浏览器，内置的JS虚拟机都有可能不同：

Safari：JavascriptCore虚拟机

Firefox：TraceMonkey虚拟机

Chrome：V8虚拟机

13.V8执行JS流程

![V8执行JS流程](https://i.loli.net/2020/10/17/PHpZ5n7OqQN2mWE.jpg)

14.对于V8这个JS虚拟机，我们会问：V8到底是解释执行JS还是编译执行JS代码呢？

15.对于以上的问题，我们给出的答案是综合运用解释执行和编译执行两种方式执行JS代码，我们把这种综合运用解释器（解释执行）和编译器（编译执行）的技术叫做JIT技术。

16.在前面的阐述中，我们可以发现，解释执行的启动速度会比编译执行的启动速度要快，也就是解释器直接接收中间代码就完全可以进行执行状态，但是编译执行最终需要接收的是01二进制代码，在接收01二进制代码的时候需要前置那些步骤，也就是接收中间代码然后转机器代码的这个过程是编译器干的，综上，可以看出启动速度对比就是解释执行直接就要中间代码启动执行，而编译执行的要的是二进制代码启动执行，所以慢了。

17.对于执行速度来说，我们发现解释执行是直接接收中间代码然后内部操作最终还是需要变01二进制代码执行起来的，但是对于编译执行直接就执行最终的二进制代码，于是我们说执行速度上很明显编译执行赢了。

18.对于启动速度和执行速度的讨论是看问题的角度不同，得出不同的结果。

19.V8执行JS之前，是需要准备JS的执行环境的，比如栈空间，堆空间，全局执行上下文，全局作用域，消息循环系统，内置函数这些。为什么需要这些呢？因为JS在执行过程当中，需要用到它们。

20.有了基础环境后，V8就开始执行JS代码。但是JS代码对V8这家伙来说，就是堆字符串，因此V8在这个过程当中要做的就是结构化这些字符串。结构化的东西我们叫做抽象语法树AST：AST = V8结构化(JS代码)，V8看得懂AST是啥。

21.在上边，V8结构化代码的最终产物还有一个玩意，就是相关作用域，然后这些作用域会存放相关变量。

22.因此总结一下：V8结构化(JS代码)-》产出AST和作用域

23.接下来，V8会根据作用域和AST产出字节码：字节码 = V8处理(作用域+AST),这就是上边说的中间代码。

24.在有了字节码后，解释器上场。它会执行字节码，然后输出执行结果：

执行结果 = 解释器(字节码)

25.在上述的解释器工作过程当中，还会有一个监督的监控解释器的家伙，它会监督解释器执行字节码。

26.为什么要监督解释器执行字节码呢？因为如果说解释器执行一段代码很频繁，这同一段代码执行了很多次，那么我们完全可以让它直接变成一段二进制代码保存起来，而这又变成了编译执行方式，为什么需要这个呢？因为我们前边知道了，编译执行代码会比解释执行快，为了更快地执行这段代码，我们可以在这里切换成编译执行的方式，毕竟这段代码用了好多次，那就直接变成二进制，执行就更快。

27.所以面对执行一段同样的代码多次，监督的家伙会把解释器执行的这一段代码给标记成为热点代码，可以理解成十分常用的具有热度的代码，它非常受解释器欢迎。

28.被标记为热点代码的字节码就会在接下来被传递给编译器而不是解释器了。

29.还记得吗？解释执行和编译执行的最开始都是一样的，都是解析器接收JS代码，输出中间的字节码。

30.然后由于字节码被继续传递的目标不一样了，产生了分叉，才出现了解释执行和编译执行。

31.因此当字节码传递给了编译器后，产出二进制机器码，这样子最终执行起来就会非常快，因为我们说过CPU最爱二进制代码，它可以读懂并执行的。

32.同时我们前边也分析了，对于执行速度来说，编译执行的过程是会比解释执行要快得多的。

33.再来复习一下，解释执行和编译执行在中间代码字节码转换上都是由解析器来处理的，不同的是二者后边的步骤不一样了。对于解释器来说，要了字节码后就立马由解释器来执行字节码了。对于编译器来说，要了字节码后，就还要继续转换成二进制机器码，然后最终交给CPU来执行这些二进制代码。

34.我们把目光回到V8里头，当热点代码被标记后，编译器就将这些代码进行转换，变成二进制代码保存起来，当V8下次执行这段代码的时候，就会优先执行这段二进制代码，代码的执行速度因此得到了大幅度的提升。

35.因为JS是动态语言，不是静态语言。它里头的对象的结构和属性是可以在运行的时候去修改的，但是热点代码如果刚好有代码对象的代码，它只能针对某种特点时刻的对象，如果你在执行的时候改掉了这个对象的样子，那么对象的结构就修改了，这样子热点代码变成的二进制代码立马就无效了，因为变了，如果再次生成的二进制代码一定不是现在的样子，所以猜测让它失效的原因在这里。

36.那优化后的代码变成了无效的代码怎么办呢？我们还是的重新执行这段代码，于是为了解决这样一个问题，出现了反优化操作这个词。

37.经过反优化的代码，在下一次执行的时候，V8就不会将这段热点代码进行编译执行一段最终的无效二进制机器码，而是使用解释器去执行那段热点代码。

38.总结反优化代码操作：反优化代码操作的目标是二进制机器码。反优化操作(二进制机器码)，下次就可以重新被V8安排解释器执行了。优化的输出是二进制，反优化的输入是二进制。
