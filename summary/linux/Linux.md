# Linux文件系统

## 磁盘分区

分区分类：主分区，扩展分区，逻辑分区。

一开始只有主分区，然后主分区最多就只有四个。但是我们还需要更多的分区，于是就从主分区分出去一个分区叫一个新名字叫做扩展分区。扩展分区最多也只有一个，我们可以在扩展分区里头继续划分更多的分区，而在扩展分区当中的这些分区就叫做逻辑分区。扩展分区唯一的作用就是去包含和划分逻辑分区，不能再扩展分区上写数据，只能在扩展分区里头的逻辑分区写数据。

## 磁盘格式化

磁盘分区完成之后，还要对分区进行格式化，才能成为文件系统供操作系统使用。

文件系统：一个可被挂载的数据就是一个文件系统

Linux当中会将权限和属性放置到inode当中，数据放入到block当中，superblock记录当前整个系统的信息（包括inode的总量，使用量，剩余量；block的总量，使用量，剩余量）。如果一个文件很大的话需要使用多个block。每一个文件都对应着一个inode。

- Inode: 代表一个文件。inode的作用就是说记录这个文件的属性，和这个文件实际存放的数据在哪些个block上边。

  ```shell
  1. 文件的权限 rwx
  2. 文件的所有者和所有组 root:root
  3. 文件的体积 11M
  4. 文件的创建时间  ctime 8月 22日 22:03
  5. 文件最近的读取时间 atime
  6. 文件最近修改时间 mtime
  7. 文件的特性 setUID
  8. 文件真正的内容指向 类似指针
  ```

  系统读取文件的时候，先去找inode，然后看看里头记录的权限是不是跟使用的人的身份符合，如果符合才去读取block的内容，不符合就不读取。

  

- data block: 放置文件里头的数据。每个block最多只能放置一个文件的数据，如果一个block放不下一个文件的内容，就需要使用多个block存放。但是如果block有剩余一样不可以放其他文件的数据了，多余就是多余了，这就可能造成空间浪费了。

- superblock：记录文件系统的整体信息。

  ```shell
  1. inode的总量、使用了多少，剩余多少
  2. block的总量，使用了多少，剩余多少
  3. 这个文件系统的挂载情况-valid bit。0就是没挂载，1就是已挂载
  ```

## 文件系统和目录树的关系

1. 在Linux系统下建立一个目录的时候，文件系统会给这个目录分配一个inode和至少一个block。
   - inode： 记录这个目录的权限和属性，同时记录分配到哪块block
   - block：记录这个目录下的文件inode和文件名字
2. 挂载点是一个目录，这个目录就是进入文件系统的入口。
3. 同一个文件系统的一个inode只会对应一个文件

## 文件系统操作

- 看一下文件系统的磁盘整体的使用量：`df`

  这个是真实的磁盘使用情况，因为磁盘是会用还包含一些后台系统进程等等占用空间

- 看一下文件系统单纯目录内容的使用量（与df不同的是，这个只计算目录，不算其他进程等）

  `du  -sh`

# Linux系统管理

## 账号管理

每个文档的所属用户指定的过程个人理解是这样的：

1. 首先分配给文档所属用户的UID，然后再跟`/etc/passwd`中这个UID的用户的昵称进行关联。
2. 如果说将这个用户的UID在`/etc/passwd`，那么文档的所属用户UID是不会有变化的。这样子文档跟所属用户就失去了关联
3. 举例子：假如一个文档的所属用户的UID是511，那么如果将用户的UID在`/etc/passwd`中改掉了，由511改成了611，那么这个文档就失去了这个原本是UID为511，现在UID是611的所属用户了。这样子一来，如果再也没有用户的UID是511的话，这份文档就是没有主人的了。
4. 可以理解成文档只认UID这个数字，不认人。

<img src="https://raw.githubusercontent.com/workcjl/image_store/main/img/Linux%E7%99%BB%E5%BD%95%E8%BF%87%E7%A8%8B.png" alt="截屏2021-08-21 13.38.20" style="zoom:50%;" />

备注：`/etc/passwd`管理账号；`/etc/shadow`管理密码	

### `/etc/passwd`账号文件

```shell
[root@linux-learning ~]# head -n 1 /etc/passwd
root
:x
:0
:0
:root
:/root
:/bin/bash
```

1. `root` 用户昵称

2. `x` 用户密码（密码被搬到/etc/shadow了，所以这里都是x）

3. `0` 用户UID（0就是系统管理员）（1-499是系统账号）

   所以要建立自定义账号从500开始建立

4. `0` 用户GID

5. `root` 用户信息说明（备注一些有关这个账号的信息而已：比如说备注账号建立的意义）

6. `/root` 主文件夹（root这个用户的主文件夹）

7. `/bin/bash` root用户当前使用的shell终端

### `/etc/shadow`密码文件

```shell
[root@linux-learning ~]# head -n 1 /etc/shadow
root
:$6$qYqmfoBLFCFK.gYz$UjfqS.LU8ri0jdLl.ywCL.n6tvgYmJPoUDzxBQgrEa3aoSKONJ7ZHQvRtSUevPl/xP5i0PeX2MJSN5rvybXnx/
:18812
:5
:10
:3
:5
:18832
: 
```

1. root` 说明了这是哪个账号的密码？是root这个账号的密码
2. `$6$qYqmfoBLFCFK.gYz$UjfqS.LU8ri0jdLl.ywCL.n6tvgYmJPoUDzxBQgrEa3aoSKONJ7ZHQvRtSUevPl/xP5i0PeX2MJSN5rvybXnx/` 这就是root的密码了，而且是加密过后的。如果输入的密码跟这里的长度内容不一样，就会没法登入，所以可以使用这个方法让密码短暂的失效。比如说在这串密码开头加一个感叹号！让root用户输入原有密码失效。
3. `18812` 最近更改密码的日期
4. `5` 在18812这个日期的5天之后才可以再次更改密码
5. `10` 在18812这个日期的10天后也就是18822这个日期需要重新更改密码（也就是冻结更改+真正需要重新更改的日期总共是10天）
6. `3` 在真正需要重新更改密码的日期前3天开始会发出密码更改的警告
7. `5` 如果在18822这个日期之后还是没有更改密码的话，这个密码就过期了。但是会告诉你有5天宽限日可以给你修改密码，这5天登陆终端都会强制让你更改密码
8. `18832` 上述操作都是在18832这个日期到来前操作才有意义的。可是只要到了18832天，账号是一整个过期了，也就没有谈论密码操作的任何意义了。因为整个账号都不能用了
9. 保留位置

总结：密码的查找是先通过UID找到用户的昵称，然后再在密码文件里头找这个昵称就可以找到对应的密码了。

### 账号操作

- 检查一个人是否在系统当中：`id 人名`

- 添加一个人到系统当中：`useradd [-u(id) -g(id) -G(其他小组名) -m(家)] 人名`

- 给刚添加的人设置进入系统的密码

  ```shell
  1. # 方式一
  passwd 人名
  
  2. # 方式二
  echo 密码 | passwd --stdin 人名
  ```

- 什么时候觉得不满意了，想要修改账号信息：`usermod [] 人名`

- 某一天一个人辞职或者被开除了，想要完全删除账号信息： `userdel [-r] 人名`

  ```shell
  userdel -r 蔡徐坤 就是删除蔡徐坤的所有信息，包括家
  ```

  



## 用户组管理

### `/etc/group`用户租文件

```shell
[root@linux-learning ~]# head -n 1 /etc/group
root:x:0:root
```

1. `root`说明有一个小组叫做root

2. `x`小组的密码（搬到/etc/gshadow了）

3. `0` 说明root这个小组的ID是0

4. `root`说明这个小组里头目前有一个人是root（一个账号是可以加入多个小组的）

   如果想让csy加入root小组的话，那么可以这么写`root:x:0:root,csy`

`root:x:0:0（0这玩意具体应该叫做初始用户组）:root:/root:/bin/bash`

意义：root这个人登录系统之后，直接就拥有了0号小组的权限了。可以执行所有0号小组内的人可以执行的任何操作。

一个人的初始小组在这个人一登录终端系统的时候就会直接拥有了，在`/etc/group`中对应的这个人的初始小组里头是不需要在最后加入这个人名的。但是如果不是这个人的初始小组，这个人想要加入其它小组，是需要在`/etc/group`这个文件里头，找到对应想要加入的小组，在小组配置的最后把这个人名加到后边去的。

问题：现在小明要建立一个文件，假如现在小明已经加入了A小组和B小组

```shell
[root@linux-learning ~]# groups
groupA groupB
```

如果说输入`groups`打印出来小明所在的小组，发现谁在第一个，就把谁叫做当前的有效小组。那么当小明建立一个test文件的时候，会发现文件的所属组是groupA。意思就是一个人创建一个新文件的时候用户所属组指的其实就是有效用户组。

问题：现在小明不满意文件属于小组A，想要替换成小组B了

```shell
[root@linux-learning ~]# newgrp groupB
[root@linux-learning ~]# groups
groupB groupA 
```

使用newgrp 小组昵称，就可以替换一个人的有效用户组。

### `/etc/group`用户组密码文件

```shell
[root@linux-learning ~]# head -n 1 /etc/gshadow
root:::root
```

1. `root` 说明这个密码是root这个小组的密码
2. 密码列
3. 用户组管理员的账号
4. `root`说明这个小组里头有哪些账号。这里说明小组里头有root用户

### 小组操作

- 往系统里头增加一个新的小组：`groupadd 小组名`
- 对成立的新小组进行操作：
  - 往新小组里头添加一个人：`gpasswd -a 人名 新小组名`
  - 往小组里头添加多个人：`gpasswd -M 甲，乙，丙 新小组名`
  - 让小组里头的某一个人成为管理员：`gpasswd -A 甲 新小组名`
  - 让小组里头的多个人成为管理员：`gpasswd -A 甲，乙 新小组名`
  - 将某个人从小组里头移除：`gpasswd -d 甲 新小组名`

# Linux权限相关

文件的权限含义

1. r对于文件的意义就是，能够读取这个文件的内容
2. w对于文件的意义就是，能够更改这个文件的内容（但是没有删除这个文件本身）
3. x对于文件的意义就是，能够执行这个文件的内容

总结：文件的权限对文件的影响是指内容的影响，而不是文件本身的影响。

目录的权限含义

1. r对于目录的意义就是，能够读取这个目录的结构

2. w对于目录的意义就是，能够更改这个目录的结构

   ```shell
   创建新的文件和目录
   删除已存在的文件和目录
   给已存在的文件和目录改名
   移动该目录内的文件、目录的位置
   ```

3. x对于目录的意义就是，能够进入这个目录里头

# Linux基本操作

## Vim编辑器

<img src="https://raw.githubusercontent.com/workcjl/image_store/main/img/Vim%E7%BC%96%E8%BE%91%E6%8C%87%E4%BB%A4.png" alt="截屏2021-08-22 13.57.47" style="zoom: 50%;" />

控制上下左右`hjkl`，口诀：左下上右

将文件另存为：`:w 新文件名字`

改变数字大小：`ctrl x`

删除一个字符： `x`

向前删除一个字符：`shift X`

选中操作：`v`加方向键可以选中光标经过的地方

`V`加方向键可以选中光标经过的行

`ctrl v` 加方向键可以选中光标经过的块

### 编辑多个文件

### 开启多个窗口





## Shell Script

### 条件判断

条件判断的表达式里头，需要前后有空格`[ "$y" == "Y" ]`

```shell
if [ "$y" == "Y" ]; then
  dosomething
elif [ "y" == "n" ]; then
  dosomething
fi
```

```shell
set -o errexit
# 如果执行命令碰到一条出错，整个停止
set -o nounset
# 如果执行的脚本当中碰到了不存在的变量，就停止执行
set -o xtrace
# 执行脚本的时候，先把命令打出来，然后再执行结果
set -o pipfail
# 执行脚本的时候，如果碰到管道命令了，那么只要管道当中有一个子命令出错的话，整个就是失败的>状态直接停止接下来的命令执行

书写所有的shell脚本的时候，将这四个一起写在开头
set -euxo pipefail
资料：http://www.ruanyifeng.com/blog/2017/11/bash-set.html
```





## Bash



## 处理文件

### gzip压缩文件

> 注意：
>
> 1. gzip压缩是直接对源文件动手脚压缩，将源文件变成压缩文件，而不是一个副本
> 2. gzip只能压缩文件，无法压缩文件夹

`gzip 压缩后的文件叫啥 要压缩的文件夹是啥`

- `gzip 1 1.txt` 高压缩文件`1.txt`，压缩后名字是`1.gz`。压缩后源文件`1.txt`就没有了。
- 压缩比高，但是不能压缩文件夹！
- `zcat 1.gz`就可以查看压缩文件的具体内容

### gzip解压文件

`gzip -d 压缩文件`

> 口诀：`gzip` 文件被压缩，`gzip`加`d`解压缩

如果想要gzip压缩后文件后继续保留原来的文件，那么需要使用`gzip -c 要压缩的文件 > 压缩后的文件名`

如果想要在在被压缩的文件里头寻找某个字符串，比如说"body"。可以这么做：`zgrep "body" 被压缩的文件 `

### bzip2压缩文件

> 注意：
>
> 1. bzip2压缩是直接对源文件动手脚压缩，将源文件变成压缩文件，而不是一个副本
> 2. bzip2只能压缩文件，无法压缩文件夹

如果想查看压缩文件里头的内容，可以使用`bzcat 被压缩的文件`

如果想搜索压缩文件里头的内容，可以使用`bzgrep 'body' 被压缩的文件`

### bzip2解压文件

`bzip2 -d 被压缩的文件`

### 打包+压缩文件夹

`tar -cf 打包后成为的文件叫啥 要打包的文件夹`

- `tar -cf book.tar book`把`book`文件夹给打包成`book.tar`文件
- 参数`-c`说明是打包过程
- 参数`-f`说明文件名是啥，这里是`book.tar`
- 注意`tar`只打包，但是不压缩。而`gzip`刚好只能压缩文件，不能压缩文件夹
- 结合`gzip`和`tar`，先将文件夹打包成一个文件，就可以使用`gzip`去压缩打包后的文件了。`tar -zcf book.tar.gz book`意思是，先用`tar`打包我的目录`book`，变成`book.tar`文件，然后使用`gzip`去压缩这个文件。这样就实现了压缩文件夹的功能。

### 解压文件夹

`tar -zxf book.tar.gz`解压缩后就是文件夹`book`

## 处理字符串

工具：正则表达式

支持的工具：grep，awk，sed

### 使用grep+正则处理字符串

### 使用sed+正则处理字符串

### 使用awk处理字符串

## 基本概念

环境变量PATH

环境变量PATH的存在让我们得以执行文件命令的时候不需要使用绝对路径的方式去执行，因为PATH环境变量帮我们指定好了命令执行的路径。

个人理解：执行任何命令`ls`等，都是在执行一个文件。这些文件一般都会放到`/bin`等启动目录下边，同时为了省略写法`/bin/ls`的方式，使用了环境变量PATH去指定这些执行文件`ls`可能所在的目录，让我们得以方便的书写`ls`。可是一旦`ls`可执行文件被搬走到其他的目录去了，结果就是命令行中输入`ls`的时候，没法在`/bin`找到了，其他PATH指定的可执行文件目录也找不到了，所以就报错了。记住一个本质：`ls`命令也是在执行一个可执行文件。

`[root@Linux1 ~]#`

- `root` 当前用户

- `Linux1 ` 主机名

- `~` 当前目录

- `#`修饰符-这个修饰符说明是超级管理员`root`

## 查看命令

### 查看目录本身的属性

`ls -dl 目录名 `

- 参数`-d`说明要查看的是目录
- 参数`-l`说明要列出目录的详细属性

### 查看正在改变的日志信息

`tail -f 日志文件`

## 文件夹处理命令

### 创建多层级的目录

`mkdir -p a/b`

- 参数`-p`说明要递归去创建，当`a`不存在时创建`a`文件夹，然后继续创建`b`文件夹

### 删除空目录

`rmdir 目录名`

- 只能删除空目录，非空目录用失败

### 删除目录

`rm -r 目录名`

- 参数`-r`代表说我是要删除的是一个目录

### 拷贝目录

`cp -r 源目录 目标路径`

- `cp -r ./folder ./a`意思是把当前的`folder`目录拷贝到当前的`a`目录里头去

### 剪切目录

`mv 要剪切的目录 要移动到的地方`

- `mv  ./b  ./a`将`b`目录剪切到`a`目录里头
- 注意：必须是不同路径！如果是相同路径，这个命令就是改名字的意思了。

## 链接命令

### 制作软链接

`ln -s 要被制作软链接的源文件的路径  制作成的软链接路径`

- `ln -s /root/a/1.txt /root/a/soft.txt`我要制作一个`1.txt`的软链接`soft.txt`。

- 注意：路径要是绝对路径！

- 软链接其实就是快捷方式，删除软链接对源文件是没有影响的。

- 软链接的作用就是可以在任何地方访问源文件。一个场景是对于安装的`java`，当使用`java`命令的时候是写死的一定去`/usr/bin/java`找。但是我们想要安装路径是在`/home/bin/java`。这时候就可以创建一个软链接，让读`/usr/bin/java`的时候找的其实是`/home/bin/java`。此时`/usr/bin/java`就是`/home/bin/java`的软链接：

  `ln -s  /usr/bin/java  /home/bin/java`

## 文件搜索

### 搜索文件

`locate 文件名`搜索你想要找的文件名

- 首先安装`yum install mlocate -y`数据库
- 然后立即生效`updatedb`数据库
- 最后使用`locate 1.txt`就可以快速搜索`1.txt`在哪里了

### 搜索命令

`whereis 命令名`搜索你想要找的命令

- `whereis ls`使用后可找到`ls`这条命令的绝对路径在哪里

###  环境变量

`$PATH` 定义着能够寻找到各种在命令行中输入的命令可能所在的环境变量

`echo $PATH` : `/root/.nvm/versions/node/v16.0.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin`

- 在终端中输入`pwd`时，先找`/root/.nvm/versions/node/v16.0.0/bin`看看底下有没这条命令，没有接着找`/usr/local/sbin`，再没有接着找`/usr/local/bin`，再没有接着找`/usr/sbin`，再没有接着找`/usr/bin`，再没有接着找`/root/bin`。最终再没有终端直接报错`command pwd not found`。

### 搜索某个范围的文件

`find 要找的地方 -name 要找的文件名`

- `find . -name 1.txt`查找当前目录下，名字是`1.txt`的文件

- 在当前目录下忽略大小写去搜索可能存在的abc.txt，abd.txt

  `find . -iname "ab[cd].txt"`。结果可能是`abc.txt`，`abd.txt`，`abC.txt`，`abD.txt`。

- 注意：文件名要使用双引号包裹，要不然会报错

- `find . -user cjl`当前目录中查找属于cjl的那些文件

- `find . mtime -5`在当前目录中查找在5天内修改过的文件

- `find . -size +10K -a -size -20K`在当前目录中查找那些大小大于`10K`且小于`20K`的文件出来

## 查找匹配字符串

`grep 要找的字符串 在哪个文件找`

- `grep name 1.txt`在`1.txt`中查找字符串`name`
- `grep -v name 1.txt`在`1.txt`中过滤掉`name`字符串把其他的字符串显示出来

## 挂载点

- 目录就是挂载点，比如`/root`就是一个挂载点
- 把目录和分区链接在一起的过程叫做挂载
- 分区就是真正的那块磁盘

  