# 字符处理

## 字符查找

### 正则表达式VS通配符

1. 正则表达式是用来匹配文件当中符合条件的字符串的，而通配符是用来匹配系统当中符合条件的文件名的。

2. 正则表达式是包含匹配，而通配符是完全匹配。

3. 常见支持正则的工具有`grep`/`awk`/`sed` ，支持通配符的有`ls`/`find`/`cp`。比如说`ls aa`就寻找完全等于aa的文件。

### 基础正则表达式

| 元字符     | 作用                                               |
| ---------- | -------------------------------------------------- |
| n*         | 找出那些没有n的行；有1个n的行；或者有连续多个n的行 |
| .          | 找出那些拥有1个字符（除了换行符）的行              |
| ^n         | 找出那些以n开头的行                                |
| n$         | 找出那些以n结尾的行                                |
| [n,m]      | 找出那些拥有[n,m]这个数组中其中1个字母的行         |
| [^n,m]     | 找出那些没有[n,m]这个数组中其中1个字母的行         |
| n\\{4\\}   | 找出那些拥有4个连续n的行                           |
| n\\{4,\\}  | 找出那些拥有最少4个连续n的行                       |
| n\\{4,6\\} | 找出那些拥有最少4个连续n，最多6个连续n的行         |

## 字符截取

### 使用`grep`提取符合条件的行

### 使用`cut`提取符合条件的列

1. `cut -f  3 file.txt`从file.txt文件中提取第3列
例子：
假设有一个表文件`file.txt`，里头的表格中每一个字段都是以`Tab`隔开（这里展示成表格只是为了方便看，实际上每一个字段之间都是1个Tab）。现在我们要从file.txt中提取出第3列的所有字段。

| ID  | Name | Gender | Mark |
| --- | ---- | ------ | ---- |
| 10  | 王武 | 男     | 60   |
| 11  | 李牧 | 男     | 54   |
| 12  | 费翔 | 男     | 78   |
| 13  | 马里 | 男     | 98   |
| 14  | 凤娇 | 女     | 87   |
| 15  | 雨濛 | 女     | 84   |

做法：`cut -f 3 file.txt`。
提取结果：

```?shell
Gender
男
男
男
男
女
女
```

注意：用这种方式提取列的话，其中的分隔符必须是制表符，也就是字段与字段直接分隔开的用的是制表符`tab`键。否则就有可能会出现提取不正确。
2. `cut -d ":" -f 1,3 /etc/passwd` 从`/etc/passwd`文件当中按照冒号作为分隔符，提取出第1列和第3列。

cut命令的局限性：如果文件是以空格符作为分隔符的话，cut命令有可能就失效了，cut命令只适合那些明确的分隔符分隔开的文本。

### 使用`awk`提取符合条件的列

1. `awk '{ printf $1 "\t" $4 "\n"}' file` 按照指定格式打印file文件的第1列和第4列。
  **处理原理**：其实系统在处理的过程当中是按照先行后列的方式来处理的。也就是说，awk会从第一行文本开始，将第一行文本的每一列赋值给`$1`到`$n`，然后作`printf` 格式化打印处理。比如，这里`printf $1 "\t" $4 "\n"`，意思就是一行行处理，按照“列1+制表符+列4+换行符”的格式打印出来，然后循环着么处理，直到把所有行处理完后结束。

  这里还可以使用`awk '{ print $1 "\t" $4 }' file`少写一个换行符（默认linux是不支持print的，但是awk可以）

2. `awk '{BEGIN print "开始打印"} {print $1 "\t" $4}'`使用`BEGIN`条件就像一个生命周期钩子一样，跟在`BEGIN`条件一块的动作，会在真正执行打印开始之前执行`BEGIN`条件后的动作。比如说，这里就是在真正处理打印整个文本的列1和列4之前输出“开始打印”的字样

3. **awk解决的一个问题**是弥补**cut**无法完成空格符完美分隔的劣势。

4. `BEGIN`的应用场景：想要使用awk指定分隔符打印的时候，可以先在BEGIN生命周期钩子上加指定分隔符的动作`BEGIN { FS = ":" }`。因为如果不加的话，比如执行`awk '{ FS = ":" }' {print $1 "\t" $3} /etc/passwd`，由于在指定分隔符的时候，系统就已经读入第一行了，所以会出现第一行root压根没被处理的情况。解决的方式就是`BEGIN { FS = ":" } { print $1 "\t" $4} /etc/passwd`。

5. **总结**：awk的格式 = `awk '[条件1]{动作1} [条件2]{动作2}'`其中条件都是可选的，可以只写动作。
