* 如果不使用简单工厂，直接去const apple = new Apple()的形式，就将实现类Apple与具体的引用变量apple耦合在了一块，假如，明天苹果Apple需要更换为🍌香蕉，那么需要改两个地方，否则只改了掉Apple变成了Banana，调用代码依旧是new Apple这样就报错了，原因是Apple已经不再存在这个类，取而代之的是Banana。
* 
* 使用简单工厂的话，不再关心new Apple的Apple类的具体实现了，也就是只需要告诉工厂Factory，我要'apple'就够，这样子耦合就解开了，const apple = Factory('apple')，至于苹果的具体实现不需要让调用者知道，你只管负责传递想要的水果类型，下次如果店家想以此充好，就可能将里头实现改掉，但是一点不影响你传递想要的类型。

总结：使用简单工厂解耦工厂代码和客户代码，将实现与客户调用分离.工厂模式的好处是只对一个factory耦合，否则需要对每一个对象耦合。这样能减少工具库和业务代码的耦合。工厂方法用于生产类的实例

* 缺点：简单工厂不符合开放封闭原则（S原则），比如如果工厂要加入新水果Lemon，除了定义Lemon的类，还要到多加一个case。开闭原则意思是只允许对扩展开放，必须对修改关闭，很明显简单工厂破坏了关闭修改的原则，因为必须到老代码去加case，这就改了factory工厂。